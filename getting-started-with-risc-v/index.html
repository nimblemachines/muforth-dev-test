<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="copyright" content="All content on muforth.dev is copyrighted. All rights are reserved." />
<meta name="description" content="Using muforth and the HiFive1 board to explore the world of RISC-V." />
<meta name="keywords" content="riscv, risc-v, muforth, forth, support, openocd, hifive1, sifive, getting started" />
<meta name="robots" content="noindex,nofollow" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:description" content="Using muforth and the HiFive1 board to explore the world of RISC-V." />
<meta name="twitter:image" content="https://www.muforth.dev/-/hifive1-board.jpg" />
<meta name="twitter:site" content="@muforth" />
<meta name="twitter:title" content="Getting started with RISC-V" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="/-/screen.css" type="text/css" />
<link rel="icon" href="/-/9s08_hc595_150x150.jpg" type="image/jpeg" />
<link rel="canonical" href="https://www.muforth.dev/getting-started-with-risc-v/" />
<title>Getting started with RISC-V &ndash; muforth</title>
</head>
<body>

<div id="header">
<h1>Getting started with RISC-V</h1>
<hr />
</div>

<div id="content">
<h2 id="introduction"><a href="#introduction">Introduction</a></h2>
<p>If you&rsquo;re here, it&rsquo;s because you want to try using <a href="/">muforth</a> to explore the world of RISC-V.</p>
<p>Currently this means that you have a <a href="https://www.crowdsupply.com/sifive/hifive1">HiFive1 board</a>; it is, at the moment, the only RISC-V hardware that muforth supports.</p>
<p>After getting a HiFive1, the next hurdle you have to jump is <a href="/getting-openocd-for-risc-v/">getting a RISC-V-aware copy of <code>openocd</code></a>. (Read that page and then come back here.)</p>
<p>You do <em>not</em> need a GCC toolchain! Yay! Jump up and down and shout with glee! <code>openocd</code> is the <em>only</em> external tool that muforth needs in order to run code on a HiFive1.</p>
<h2 id="getting-muforth"><a href="#getting-muforth">Getting muforth</a></h2>
<p>If you&rsquo;ve never used muforth before, <a href="https://github.com/nimblemachines/muforth">get a copy</a>. <a href="https://github.com/nimblemachines/muforth/blob/master/BUILDING">BUILDING</a> has the very simple instructions for building muforth.</p>
<p>Once it is built, cd to <code>muforth/mu/</code>. You should <em>always</em> be in this directory when running muforth code.</p>
<h2 id="connecting"><a href="#connecting">Connecting</a></h2>
<p>Edit the file <code>target/RISC-V/start-openocd.sh</code> and change the <code>openocd</code> variable so it references <em>your</em> local copy of the RISC-V <code>openocd</code>, and if you are Linux, modify the <code>libusb_dir</code> variable to point to a directory that contains libusb. If you are using the CentOS version of SiFive&rsquo;s prebuilt <code>openocd</code>, <code>libusb_dir</code> can be simply <code>&lt;riscv-openocd-centos&gt;/lib</code>.</p>
<p>If you are on a Mac and running Mavericks or later, unload the Apple FTDI driver; otherwise it will interfere with JTAG:</p>
<pre>
  sudo kextunload /System/Library/Extensions/AppleUSBFTDI.kext/
</pre>
<p>Plug your HiFive1 into a USB port. Open a second terminal window, leaving the first one sitting in <code>muforth/mu</code>. cd to <code>muforth/mu</code> in this window as well. Then type the following command to start up <code>openocd</code>:</p>
<pre>
  target/RISC-V/start-openocd.sh
</pre>
<p>Back in the first <code>muforth/mu</code> window type this:</p>
<pre>
  ./muforth -d openocd -f target/RISC-V/build.mu4
</pre>
<p>This will load the RISC-V meta-compiler and the RISC-V Forth kernel (which currently loads into RAM). To connect to the board via JTAG, type</p>
<pre>
  jtag
</pre>
<p>You should see a dump of four registers, all zero except for SP. You are now connected to the target board!</p>
<h2 id="exploring"><a href="#exploring">Exploring</a></h2>
<h4 id="disassembling-risc-v-code"><a href="#disassembling-risc-v-code">Disassembling RISC-V code</a></h4>
<p>To see some of the kernel code that was loaded into RAM, try this:</p>
<pre>
  @ram dis
</pre>
<p>This will start disassembling the beginning of the Forth kernel. All memory dumping and disassembly in muforth is <em>interactive</em>; pressing &lt;RET&gt; or n will advance; pressing &lt;BS&gt; or p will back up; q will quit, leaving the last-viewed address on the stack.</p>
<p>The word <code class="forth">@ram</code> is a constant; executing it pushes the address of the start of RAM (&ldquo;at-ram&rdquo;).</p>
<p>You can also look at built-in features. The Debug ROM is interesting. To see it type</p>
<pre>
  0800 dis
</pre>
<p>and keep pressing &lt;RET&gt; to see further lines. Compare what you see here to what is documented in the <a href="https://dev.sifive.com/documentation/risc-v-external-debug-support-0-11/">debug spec version 0.11</a> <a href="https://static.dev.sifive.com/riscv-debug-spec-0.11nov12.pdf">(direct link)</a>.</p>
<h4 id="executing-target-forth-words"><a href="#executing-target-forth-words">Executing target Forth words</a></h4>
<p>To try actually executing some code, try this:</p>
<pre>
  10305 2040 +
</pre>
<p>This pushes two hex values onto the stack, copies this stack over to the target, executes the word <code class="forth">+</code> on the target, which adds them and pushes their sum, and then copies that back to the target. You should see the result in the stack dump.</p>
<p>To list the words in the target kernel, try this:</p>
<pre>
  target words
</pre>
<h4 id="peering-inside-the-fe310"><a href="#peering-inside-the-fe310">Peering inside the FE310</a></h4>
<p>Something more interesting: Let&rsquo;s write a word to read the value of one of the chip&rsquo;s CSRs. This one &ndash; <code>misa</code> &ndash; tells us which base ISA &ndash; RV32 or RV64 &ndash; and which extensions the chip supports.</p>
<pre>
  code read-misa   misa w csrr   wpush j  ;c
  read-misa
</pre>
<p>The first line <em>defines</em> <code>read-misa</code> as a &ldquo;code&rdquo; word. This means that its definition is entirely in RISC-V assembler. It consists of just two instructions: one to read the CSR into the w register (an alias for ABI register t0), and one to jump to a routine that pushes w onto the stack and then executes NEXT. (On an ITC Forth all code words have to end by executing NEXT, directly or indirectly.)</p>
<p>The second lines executes our new word, and the result should show up on the stack. By reading the privileged ISA spec (see <a href="/risc-v-resources/">RISC-V resources</a>) we can peel this apart. But first, let&rsquo;s print its value in binary to make it easier to see:</p>
<pre>
  binary u. hex
</pre>
<p>This switches the input and output radix to binary, prints as an unsigned number the top of the stack (the contents of <code>misa</code>), then switches back to hex.</p>
<p>Unfortunately, <code class="forth">u.</code> doesn&rsquo;t print leading zeros, so it&rsquo;s hard to tell that the top two bits &ndash; which define the base ISA &ndash; are <code>01</code> &ndash; meaning RV32. The low order 26 bits each correspond to an ISA extension; the bit is set when that extension is present. I read the result as showing that IMAC are all present &ndash; exactly what we would expect from the FE310.</p>
<h4 id="writing-forth-words"><a href="#writing-forth-words">Writing Forth words</a></h4>
<p>Next, let&rsquo;s try a simple &ldquo;colon&rdquo; word. A colon word is any word defined by <code class="forth">:</code> whose body consists of other Forth words. Most Forth code is colon words rather than code words.</p>
<pre>
  : bic   ( value mask - result)   invert and ;
</pre>
<p><code class="forth">bic</code> is the logical &ldquo;bit clear&rdquo; operation. It takes two parameters &ndash; shown in the &ldquo;stack comment&rdquo; (in parentheses) on the left of the dash &ndash; and produces one result &ndash; shown to the right of the dash. The first word, <code class="forth">invert</code>, does a ones complement of the mask; this is then <code>and</code>ed with the value. Any one bits in the mask clear the corresponding bit in the value. As usual, we see the result on the stack dump (which is always in hex, regardless of the setting of the input/output radix &ndash; an odd quirk of muforth).</p>
<p>Colon words always end with a <code class="forth">;</code>. When execution reaches this point, the word returns to its caller.</p>
<p>Let&rsquo;s try it.</p>
<pre>
  c0defeed ffff0000 bic
</pre>
<p>Hopefully the resulting value makes sense.</p>
<h4 id="how-numbers-work"><a href="#how-numbers-work">How numbers work</a></h4>
<p>A couple of notes about numbers in muforth. Any number can be prefixed by a radix operator, which changes the radix <em>for that number only</em>. The operators, and their resulting radices, are:</p>
<pre>
  %  binary
  '  octal
  "  hexadecimal
  #  decimal
</pre>
<p>These can be handy if you are writing an assembler where most values are in octal but need to switch to another radix to enter a single value.</p>
<p>Following the (optional) radix operator can be an optional sign operator: the usual &ldquo;-&rdquo; character.</p>
<p>Another thing: numbers are generally printed with separators. This makes them much easier to parse. They can also be <em>input</em> with separators. Any of the following characters is a valid separator:</p>
<pre>
  . , : / _ -
</pre>
<p>You should also realize that numbers are 64-bit on the host stack (in muforth) but truncated to 32-bits when copied over to the target.</p>
<p>Our stack has now accumulated some junk. You can get rid of it by typing</p>
<pre>
  .
</pre>
<p>over and over. Each execution of <code class="forth">.</code> prints as a <em>signed</em> value the top of the stack, thus removing one value. If there is a ton of junk on the stack, the word <code class="forth">sp-reset</code> clears the stack in one go.</p>
<h4 id="writing-loops"><a href="#writing-loops">Writing loops</a></h4>
<p>Forth has both <em>definite</em> and <em>indefinite</em> loops. Definite loops are based on a count; indefinite loops loop until some condition becomes true. Let&rsquo;s look each in turn.</p>
<p>There are two kinds of definite loops: for/next and do/loop. We use for/next when we want to iterate a known number of times and don&rsquo;t care about the <em>value</em> of the loop index. (It&rsquo;s hidden from our code, but the loop index counts down to zero from the given starting value.) Let&rsquo;s try two versions of for/next: one that simply does a calculation, and one that has a &ldquo;bug&rdquo; in it, so it stops every time through to let us look around.</p>
<p>Try this:</p>
<pre>
  : lshift  ( n #shifts)  for 2* next ;
  0abcd 4 lshift
</pre>
<p>We&rsquo;ve included a stack comment to remind us what&rsquo;s going on here. (We are basically re-implementing <code class="forth">&lt;&lt;</code> in Forth.) Since <code class="forth">2*</code> shifts left by one bit, the loop will shift left by the number of bits specified.</p>
<p>Now the bugged version:</p>
<pre>
  : lshift-bug  ( n #shifts)  for 2* bug next ;
  0abcd 4 lshift-bug
</pre>
<p>When you first execute <code class="forth">lshift-bug</code> you&rsquo;ll see that the IP register has a <code>*</code> next to it. This means that execution of your word did not complete. We are somewhere in the body of word (in this case, <code class="forth">lshift-bug</code>) and we can look around. There is not much to see; however, the value on the stack has been shifted left by one bit. Now type</p>
<pre>
  cont
</pre>
<p>to continue execution. The same thing will happen. IP will be starred, and the value on the stack will have been shifted left again. Keep typing <code>cont</code> until IP is unstarred. Execution has completed and we should see the same result on the stack that we got with <code class="forth">lshift</code>.</p>
<p>One note here: muforth has primitive but very useful command history. You can use the up and down arrow keys to navigate the command history, and the left and right arrow keys to move around and change a previously-entered line of text. Pressing enter will execute the edited version. If you use any command-line shell, the behavior should feel familiar. (And for the inveterately curious, this is implemented entirely in Forth! See the file <a href="https://github.com/nimblemachines/muforth/blob/master/mu/lib/editline.mu4">lib/editline.mu4</a> for the gory details. It&rsquo;s a whopping 175 lines of code!)</p>
<p>The second kind of definite loop is the <code class="forth">do</code> loop. It consumes two values from the stack &ndash; a limit and an index &ndash; and loops until the index reaches or crosses the limit. In the body of the loop the word <code class="forth">i</code> pushes the current loop index onto the stack.</p>
<p>A do loop always starts with <code class="forth">do</code> but can end with either <code class="forth">loop</code> or <code class="forth">+loop</code>. <code class="forth">loop</code> increments the index by 1; <code class="forth">+loop</code> consumes a stack value and increments the index by that value. Since it will be hard to see what&rsquo;s going on if we let these run free, let&rsquo;s only try the bugged versions.</p>
<p>Try this:</p>
<pre>
  : doit  ( limit index)  do  i bug drop  loop ;
  5 0 doit
</pre>
<p>This should count <em>up</em> &ndash; starting at index, continuing until index reaches limit &ndash; from 0 to 4. <code class="forth">i</code> will push the current index, <code class="forth">bug</code> will stop so we can see it on the stack, and then <code class="forth">drop loop</code> will throw away the current index value, and loop again, or exit.</p>
<p>As before, keep typing <code>cont</code> until IP is unstarred. Try some other limits and indices and see what happens.</p>
<p>Now the <code class="forth">+loop</code> version:</p>
<pre>
  : doit+  ( incr limit index)  do  i bug drop  dup +loop  drop ;
  -3 -20 -10 doit+
</pre>
<p>Note that we are passing an increment to <code class="forth">doit+</code> (the -3 value) and using <code class="forth">dup</code> to make a copy of it before calling <code class="forth">+loop</code> so we can use it the next time around as well. Since at the end of the loop the increment will <em>still</em> be sitting on the stack, we <code class="forth">drop</code> when we are done.</p>
<p>As before, keep typing <code>cont</code> until IP is unstarred. Try some other increments, limits, and indices and see what happens. Since the stack dump shows unsigned hex values it can be hard to see what&rsquo;s going on here. The first time you stop at the bug, try doing</p>
<pre>
  over .
</pre>
<p>to see the increment value (-3). And <em>every</em> time you stop at the bug, try</p>
<pre>
  dup .
</pre>
<p>to see the current loop index. <code class="forth">.</code> will sign-extend the 32-bit target value to 64-bits and then print it as a signed number. This should help. Remember too: all those loop values are in <em>hexadecimal</em>! So, -10 is really -16 (decimal), and -20 is really -32 (decimal).</p>
<p>Does the behavior of <code class="forth">doit+</code> make sense? Try different values of the increment, limit, and index.</p>
<p>Using negative increments with do loops seems to have odd behavior in that the idea of &ldquo;reaching or crossing&rdquo; the limit seems different from the behavior with positive increments.</p>
<p>The behavior that you see here conforms to &ldquo;standard&rdquo; Forth practice, and is essentially a result of the <em>implementation</em>: the index value is translated (shifted along the integer &ldquo;number line&rdquo;) so that the loop terminates when the translated index crosses the threshold from <code>0000_0000</code> to <code>ffff_ffff</code> (when counting down) or from <code>ffff_ffff</code> to <code>0000_0000</code> (when counting up). You can see the translated index in the IX register during loop execution.</p>
<p>So what about <em>indefinite</em> loops? There are two varieties of these as well: one that always executes the loop body at least once (like C&rsquo;s do...while) and one that tests the termination condition at or near the beginning (like C&rsquo;s while). Here they are:</p>
<pre>
  begin  &lt;loop body&gt;  &lt;condition&gt; until
  begin  &lt;condition&gt; while  &lt;loop body&gt;  repeat
</pre>
<p>There is also an unending version that we won&rsquo;t be trying out here:</p>
<pre>
  begin  &lt;loop body&gt;  again
</pre>
<p>which is useful for the main loop of an embedded application.</p>
<p>I&rsquo;m going to write &ldquo;bugged&rdquo; versions of these. Feel free to try them with or without the bug. Try these definitions:</p>
<pre>
  : overflow  ( n - n')  begin  2*  bug  dup 0&lt; until ;
  800_0000 overflow
</pre>
<p>The word <code class="forth">0&lt;</code> consumes the value on the stack (hence we <code class="forth">dup</code> it first) and pushes -1 (true) if the value is less than 0, and 0 (false) otherwise.</p>
<p>Don&rsquo;t pass 0 to <code class="forth">overflow</code>. ;-)</p>
<pre>
  : till-even  ( n - n')  begin  dup 1 and  bug  0= while  u2/  repeat ;
  47 till-even
</pre>
<p>A bit of explanation. <code class="forth">0=</code> is like <code class="forth">0&lt;</code>: it consumes a value and pushes -1 if it is equal to zero and 0 otherwise. <code class="forth">dup 1 and</code> makes a copy of a value and then tests the low-order bit (which is 1 if the value is odd). <code class="forth">u2/</code> does an <em>unsigned</em> right shift by one bit. (<code class="forth">2/</code> is the <em>signed</em> version.) I&rsquo;ve placed the bug to show <em>both</em> the value being tested <em>and</em> its low-order bit.</p>
<p>Remember: the stack is showing <em>hex</em> values. If you <em>really</em> want to see what&rsquo;s going on, set the radix to <code class="forth">binary</code>, and use <code class="forth">over u.</code> to copy and print the value on the stack each time through the loop. (<code class="forth">over</code> makes a copy of the second value on the stack, where <code class="forth">dup</code> copies the top value.)</p>
<h4 id="go-forth-and-conquer"><a href="#go-forth-and-conquer">Go forth and conquer!</a></h4>
<p>I hope this whets your appetite for more! There is a lot more coming. See <a href="/risc-v-support/">RISC-V support</a> to see the current state of things.</p>
<h2 id="risc-v-and-sifive-documentation"><a href="#risc-v-and-sifive-documentation">RISC-V and SiFive documentation</a></h2>
<p>I&rsquo;ve compiled a page with lots of <a href="/risc-v-resources/">RISC-V resources</a>.</p>

</div>

<div id="footer">
<hr />
<a href="mailto:%77%65%62%68%61%6d%73%74%65%72%40%6e%69%6d%62%6c%65%6d%61%63%68%69%6e%65%73%2e%63%6f%6d?subject=%5bmuforth%5d%20Getting%20started%20with%20RISC-V">Send feedback</a> on this page (last edited 2019 September 17 17:24)<br />
Browse <a href="/all-pages/">all pages</a>, or return <a href="/">home</a><br />
<a href="https://twitter.com/share?url=https%3a%2f%2fwww.muforth.dev%2fgetting-started-with-risc-v%2f&text=Say%20something%20nice!">Tweet</a> this page, or follow <a href="https://twitter.com/muforth">@muforth</a>
</div>

</body>
</html>
